# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/0090_prepare_dataset.ipynb (unless otherwise specified).

__all__ = ['pixel_to_img_coords_with_shape', 'get_grid', 'data_decimate', 'halton', 'halton_sequence', 'image_decimate',
           'get_frame_index_from_name', 'save_downscaled_exr_decimate', 'downscale_exr_folder_decimate']

# Cell
from IPython.display import display,HTML
from typing import Any, Callable, Optional, List, Dict, Iterator, Set, Tuple
import shutil

# Cell
from fastai.vision.all import *
import PIL
import torch
import numpy as np
import Imath, OpenEXR

# Cell
from fastprogress.fastprogress import master_bar, progress_bar

from .config import data_folder, DatasetSpec
from .image import load_exr, save_exr, show_img

# Cell
#this functions is similar to pixel_to_img_coords in 0180_TAA (move it to another notebook)
def pixel_to_img_coords_with_shape(xy_coords, img_width:int, img_height:int, xy_offset=None):
    """Convert xy coordinates expressed in pixels (e.g. from motion vectors) into a range of [-1,1].

        Args:
            xy_coords: (N,H,W,2) where the last axis is an absolute (x,y) coordinate expressed in pixels.
            img_width: image width
            img_height: image height

        Return:
            xy_coords: (N,H,W,2) where the last axis should range between [-1,1], except if the coordinates were out-of-image."""
    if xy_offset is None:
        xy_offset = tensor([0.0, 0.0])

    # TODO: think whether this should be detached...? do we need to propagate gradients?
    xy_coords = xy_coords.clone().detach()

    xy_coords[..., 0:1] = (xy_coords[..., 0:1] + xy_offset[0]) / (img_width-1) * 2 - 1.0 # x coordinates
    xy_coords[..., 1:2] = (xy_coords[..., 1:2] + xy_offset[1]) / (img_height-1) * 2 - 1.0 # y coordinates
    return xy_coords

# Cell
def get_grid(shapeHr, KernelSize, anchor):
    """Creates a grid for xy coordinates of pixels into range of [-1,1]

        Args:
            shapeHr: shape of given image (High resolution image)
            KernelSize: size of kernel in (x,y) coordinates manner
            anchor: position of pixel around of center of the kernel size

        Return:
            xy_coords: (N,H,W,2) where the last axis should range between [-1,1], except if the coordinates were out-of-image.
    """
    x = torch.arange(start = 0, end = shapeHr[-1], dtype = torch.float32)
    y = torch.arange(start = 0, end = shapeHr[-2], dtype = torch.float32)
    #create xy offsets
    x_offset = x[KernelSize[0] // 2 - 1 + anchor[0]::KernelSize[0]]
    y_offset = y[KernelSize[1] // 2 - 1 + anchor[1]::KernelSize[1]]
    #mesh grid for pixel indexes of x and y coordinates
    meshy, meshx = torch.meshgrid((y_offset, x_offset))
    #created mesh
    stacked_mesh = torch.stack([meshx, meshy], axis=-1).unsqueeze(0)

    #coordinates grid
    return pixel_to_img_coords_with_shape(stacked_mesh, shapeHr[-1], shapeHr[-2])

# Cell
def data_decimate(tensorHr, KernelSize, anchor):
    """Decimates a given image

        Args:
            tensorHr: high resolution torch tensor (HR image)
            KernelSize: size of kernel in (x,y) coordinates manner
            anchor: position of pixel around of center of the kernel size

        Return:
            TensorImage: decimated tensor
    """
    n = tensorHr.shape[0]
    w = tensorHr.shape[2] // KernelSize[0]
    h = tensorHr.shape[1] // KernelSize[1]
    grid = get_grid(tensorHr.shape, KernelSize, anchor)
    tensor = F.grid_sample(tensorHr.unsqueeze(0).float(), grid, mode='nearest')

    return TensorImage(tensor.squeeze(0))


# Cell
def halton(index, base):
    """Creates a halton index value

        Args:
            index: number/index of sequence
            base: base of given sequence

        Return:
            result: value of given sequence
    """
    f = 1.0
    result = 0.0
    i = index
    while i > 0:
        f /= base
        result += f * (i % base)
        i = i // base

    return result

# Cell
def halton_sequence(frame_index, KernelSize):
    """Creates a halton sequence

        Args:
            frame_index: index of frame in given video
            KernelSize: size of kernel in (x,y) coordinates manner

        Return:
            (x,y): returns a value of pixel coordinate
    """
    jitter_index = 1 + (frame_index & 0xf)

    jitter_x = (2 * halton(jitter_index, 2)) - 1
    jitter_y = (2 * halton(jitter_index, 3)) - 1

    x = int(KernelSize[0] // 2 * jitter_x + 0.5)
    y = int(KernelSize[1] // 2 * jitter_y + 0.5)

    return (x,y)

# Cell
def image_decimate(tensorHr, KernelSize, frame_index):
    """Decimates an image at given video frame

        Args:
            tensorHr: high resolution torch tensor (HR image)
            KernelSize: size of kernel in (x,y) coordinates manner
            frame_index: frame index in given video

        Return:
             data_decimate: decimated photo from HR to LR
    """
    anchor = halton_sequence(frame_index, KernelSize)

    return data_decimate(tensorHr, KernelSize, anchor)


# Cell
def get_frame_index_from_name(in_file):
    res = [int(s) for s in re.findall('\\d+', in_file)]
    return int(res[0])

# Cell
#this functions is similar to save_downscaled_exr in 0030_image (move it to another notebook)
import cv2
def save_downscaled_exr_decimate(in_path:Path, out_path:Path, width:int, height:int, frame_index:int, show=False):
    """Save a downscaled copy of the EXR image from `in_path`. Save the `width`x`height` result in `out_path`.

        Assumptions:
            - Input, output are 16-bit EXR
            - Width/height aspect ratio is preserved    """

    img_hr = load_exr(str(in_path))
    KernelSize = (img_hr.shape[2]//width, img_hr.shape[1]//height)
    img_lr = image_decimate(img_hr, KernelSize, frame_index) # low-res image
    save_exr(img_lr, str(out_path))

    if show: show_img(img_lr, figsize=(15,8))

# Cell
#this functions is similar to downscale_exr_folder in 0030_image (move it to another notebook)
def downscale_exr_folder_decimate(in_folder:Path, out_folder:Path, width:int, height:int, show=False, jitter=False):
    """Save a downscaled copy of every .exr image in `in_folder`, into `out_path`, with same filenames.

        Assumptions: same as `save_downscaled_exr_decimate`"""
    files = list(in_folder.glob("*.exr"))
    for i in progress_bar(range(len(files))):
        in_file = files[i]
        if jitter:
            frame_idx = get_frame_index_from_name(str(in_file.name))
            save_downscaled_exr_decimate(in_file, out_folder/in_file.name, width, height, frame_index, show=show)
        else:
            save_downscaled_exr_decimate(in_file, out_folder/in_file.name, width, height, 0, show=show)
